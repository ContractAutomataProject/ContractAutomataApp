package CA;
import java.io.BufferedReader;
import java.io.InputStreamReader;

import FSA.FSA;
import FSA.Simulator;
import FSA.Transition;


/**
 * @author Davide Basile
 *
 */
@SuppressWarnings("serial")
public class CA  extends FSA implements java.io.Serializable
{
	private int rank;
	private int[] initial;
	private int[] states;
	private int[][] finalstates; 
	private Transition[] tra;
	private static String message = "*** CA simulator ***\n";
	
	/**
	 * Invoke the super constructor and take in input the added new parameters of the automaton
	 */
	public CA()
	{
		super(message);
		this.rank = 1;
		this.states = new int[1];
		this.states[0] = super.getStates();
		this.initial = new int[1];
		initial[0] = super.getInitial();
		finalstates = new int[1][super.getFinalStates().length];
		finalstates[0]= super.getFinalStates();
	}
	
	
	/**
	 * Print in output a description of the automaton
	 */
	public void print()
	{
		super.print();
	}
	
	
	
	/**
	 * Create an instance of the simulator for an FMA
	 */
	protected Simulator createSim()
	{
		//return new FMASimulator(this);
		return null;
	}
	
	/**
	 * 
	 * @param i		the index of the transition to be showed as a message to the user
	 * @return		a new Transition for this automaton
	 */
	protected Transition createTransition(int i)
	{
		return new CATransition(i);
	}
	
	
	/**
	 * 
	 * @return	the array of final states
	 */
	public int[][] getFinalStatesCA()
	{
		return finalstates;
	}
	
	/**
	 * 
	 * @return	the number of states
	 */
	public int[] getStatesCA()
	{
		return states;
	}
	
	/**
	 * 
	 * @return the rank of the Contract Automaton
	 */
	public int getRank()
	{
		return rank;
	}
	
	
	public static CA product(CA[] aut)
	{
		/**
		 * compute rank, states, initial states, final states
		 */
		int prodrank =0;
		for (int i=0;i<aut.length;i++)
		{
			prodrank = prodrank+(aut[i].getRank()); 
		}
		int[] statesprod = new int[prodrank];
		int[][] finalstatesprod = new int[prodrank][];
		int[] initialprod = new int[prodrank];
		for (int i=0;i<prodrank;i++)
		{
			for (int j=0;j<aut[i].getRank();j++)
			{
				statesprod[i]= aut[i].getStatesCA()[j];			
				finalstatesprod[i] = aut[i].getFinalStates();
				initialprod[i] = aut[i].getInitial();
			}
		}
		/**
		 * compute transitions, non associative
		 * 
		 * scan all pair of transitions, if there is a match
		 * then the new match is added, otherwise interleaving		 * 
		 */
		Transition[][] prodtr = new CATransition[aut.length][];
		int trlength = 0;
		for(int i=0;i<aut.length;i++)
		{
			prodtr[i]= aut[i].getTransition();
			trlength += prodtr[i].length;
		}
		Transition[] transprod = new CATransition[trlength];
		int pointer = 0;
		boolean match = false;
		for (int i=0;i<prodtr.length;i++)
		{
			Transition[] t = prodtr[i];
			for (int j=0;j<t.length;j++)
			{
				for (int ii=i+1;ii<prodtr.length;ii++)
				{
					Transition[] tt = prodtr[ii];
					for (int jj=0;jj<tt.length;jj++)
					{
						if (t[j].getLabel() + tt[jj].getLabel() == 0) //match found
						{
							match = true;
							transprod[pointer] = new CATransition
						}
					}
				}
				if (!match) //if t[j] it is not matched then interleaving
				{
					
				}
			}
		}
				
			
		return null;
	}
	
	public CA proj(int i)
	{
		if ((i<0)||(i>rank)) //check if the parameter i is in the rank of the CA
			return null;
		
		
		return null;
	}
	
	public static CA aproduct(CA[] automata)
	{
		return null;
	}
	
	public boolean branchingCondition()
	{
		return false;
	}
	
	public boolean mixedChoice()
	{
		return false;
	}
}
